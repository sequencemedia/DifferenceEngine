// Generated by LiveScript 1.3.1
var ArrayEngine;
ArrayEngine = (function(){
  "use strict";
  ArrayEngine.displayName = 'ArrayEngine';
  var ARRAY, i, j, m, lowerBound, upperBound, lastIndex, lastValue, nearestLastIndex, nearestLastValue, prototype = ArrayEngine.prototype, constructor = ArrayEngine;
  function ArrayEngine(array){
    if (array) {
      this.begin(array);
    } else {
      this.reset();
    }
  }
  prototype.indexOf = function(v){
    var a, x, y, i$;
    if (lastValue === v) {
      return lastIndex;
    } else if (upperBound || lowerBound) {
      a = ARRAY;
      x = 0;
      y = j;
      for (i$ = 0; i$ <= y; ++i$) {
        x = i$;
        if (a[x] === v) {
          lastValue = v;
          return lastIndex = x;
        }
      }
    }
    return null;
  };
  prototype.nearestIndexOf = function(v){
    var a, x, y, i$, n;
    if (nearestLastValue === v) {
      return nearestLastIndex;
    } else if (upperBound || lowerBound) {
      a = ARRAY;
      x = Math.min(y = j, nearestLastIndex + 1);
      for (i$ = x; i$ <= y; ++i$) {
        n = i$;
        if (a[n] === v) {
          nearestLastValue = v;
          return nearestLastIndex = n;
        }
      }
      x = Math.max(y = m, nearestLastIndex - 1);
      for (i$ = x; i$ >= y; --i$) {
        n = i$;
        if (a[n] === v) {
          nearestLastValue = v;
          return nearestLastIndex = n;
        }
      }
    }
    return null;
  };
  prototype.begin = function(array){
    if ((array || false).constructor === Array) {
      i = +0;
      j = (ARRAY = array.slice()).length;
      m = -1;
      lowerBound = i;
      upperBound = j - 1;
      lastIndex = nearestLastIndex = m;
      lastValue = nearestLastValue = null;
    } else {
      this.reset();
    }
    return this;
  };
  prototype.reset = function(){
    i = +0;
    j = (ARRAY = []).length;
    m = -1;
    lowerBound = i;
    upperBound = m;
    lastIndex = nearestLastIndex = m;
    lastValue = nearestLastValue = null;
    return this;
  };
  prototype.bite = function(x, y){
    var pow, N, max, min, l, u;
    if (typeof x === "number") {
      pow = Math.pow;
      N = Number.NEGATIVE_INFINITY;
      max = Math.max;
      min = Math.min;
      l = lowerBound;
      u = upperBound;
      if (typeof y === "number") {
        if (pow(x, m) === N && pow(y, m) === N) {
          return ARRAY.slice(l).reverse();
        } else {
          x = max(l, min(u, x > m
            ? x
            : x + u));
          y = min(u, max(l, y > m
            ? y
            : y + u));
          return x > y
            ? ARRAY.slice(y, x + 1).reverse()
            : ARRAY.slice(x, y + 1);
        }
      }
      if (pow(x, m) === N) {
        return ARRAY.slice(u);
      } else {
        x = max(l, min(u, x > m
          ? x
          : x + u));
        return ARRAY.slice(x);
      }
    }
    return [];
  };
  prototype.map = function(method){
    var z, array;
    if ((method || false).constructor === Function) {
      if ((z = lowerBound) < j) {
        array = [];
        do {
          array.push(method.call(ARRAY, z, ARRAY[z], j));
        } while (++z < j);
        return array;
      }
    }
    return [];
  };
  prototype.max = function(){
    var max, MAX;
    max = Math.max;
    MAX = function(a){
      var x, z, y;
      x = a[0];
      z = 1;
      do {
        if ((y = a[z]) > x) {
          x = y;
        }
      } while (++z < j);
      return x;
    };
    return function(){
      var z, a;
      return i < j ? isNaN(z = max.apply(a = ARRAY, a)) ? MAX(a) : z : null;
    };
  }();
  prototype.min = function(){
    var min, MIN;
    min = Math.min;
    MIN = function(a){
      var x, z, y;
      x = a[0];
      z = 1;
      do {
        if ((y = a[z]) < x) {
          x = y;
        }
      } while (++z < j);
      return x;
    };
    return function(){
      var z, a;
      return i < j ? isNaN(z = min.apply(a = ARRAY, a)) ? MIN(a) : z : null;
    };
  }();
  prototype.iterate = function(method){
    if ((method || false).constructor === Function) {
      throw "Not implimented";
    }
    return false;
  };
  prototype.iterateForward = function(method){
    var z, u;
    if ((method || false).constructor === Function) {
      if ((z = lowerBound) < j) {
        u = upperBound;
        do {
          method.call(ARRAY, z, ARRAY[z], u);
        } while (++z < j);
        return true;
      }
    }
    return false;
  };
  prototype.iterateReverse = function(method){
    var z, u;
    if ((method || false).constructor === Function) {
      if ((z = u = upperBound) < j) {
        do {
          method.call(ARRAY, z, ARRAY[z], u);
        } while (m < --z);
        return true;
      }
    }
    return false;
  };
  prototype.iterateBetween = function(x, y, method){
    var a, l, u, max, min, z;
    if (typeof x === "number" && typeof y === "number" && (method || false).constructor === Function) {
      a = ARRAY;
      l = lowerBound;
      u = upperBound;
      max = Math.max;
      min = Math.min;
      x = max(l, min(u, x > m
        ? x
        : x + u));
      y = min(u, max(l, y > m
        ? y
        : y + u));
      if (x > y) {
        z = y - 1;
        do {
          method.call(a, x, a[x], y);
        } while (z < --x);
        return true;
      } else {
        z = y + 1;
        do {
          method.call(a, x, a[x], y);
        } while (++x < z);
        return true;
      }
    }
    return false;
  };
  return ArrayEngine;
}());